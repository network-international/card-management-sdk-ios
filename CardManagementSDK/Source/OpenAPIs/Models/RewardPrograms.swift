//
// RewardPrograms.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

internal struct RewardPrograms: Codable, JSONEncodable, Hashable {

    static let rewardTypeRule = StringRule(minLength: 1, maxLength: 3, pattern: nil)
    static let rewardOpenBalanceRule = StringRule(minLength: 1, maxLength: 3, pattern: nil)
    static let rewardBalanceRule = StringRule(minLength: 1, maxLength: 20, pattern: nil)
    static let rewardEarnedRule = StringRule(minLength: 1, maxLength: 20, pattern: nil)
    static let rewardRedeemedRule = StringRule(minLength: 1, maxLength: 20, pattern: nil)
    static let rewardAdjustRule = StringRule(minLength: 1, maxLength: 20, pattern: nil)
    static let rewardTotalEarnedRule = StringRule(minLength: 1, maxLength: 20, pattern: nil)
    /** Reward type */
    internal var rewardType: String?
    /** Reward open balance */
    internal var rewardOpenBalance: String?
    /** Reward balance on the current billing cycle */
    internal var rewardBalance: String?
    /** Reward earned points on the current billing cycle */
    internal var rewardEarned: String?
    /** Reward redeemed points on the current billing cycle */
    internal var rewardRedeemed: String?
    /** Reward adjust points on the current billing cycle */
    internal var rewardAdjust: String?
    /** Reward earned points on the current billing cycle */
    internal var rewardTotalEarned: String?

    internal init(rewardType: String? = nil, rewardOpenBalance: String? = nil, rewardBalance: String? = nil, rewardEarned: String? = nil, rewardRedeemed: String? = nil, rewardAdjust: String? = nil, rewardTotalEarned: String? = nil) {
        self.rewardType = rewardType
        self.rewardOpenBalance = rewardOpenBalance
        self.rewardBalance = rewardBalance
        self.rewardEarned = rewardEarned
        self.rewardRedeemed = rewardRedeemed
        self.rewardAdjust = rewardAdjust
        self.rewardTotalEarned = rewardTotalEarned
    }

    internal enum CodingKeys: String, CodingKey, CaseIterable {
        case rewardType = "reward_type"
        case rewardOpenBalance = "reward_open_balance"
        case rewardBalance = "reward_balance"
        case rewardEarned = "reward_earned"
        case rewardRedeemed = "reward_redeemed"
        case rewardAdjust = "reward_adjust"
        case rewardTotalEarned = "reward_total_earned"
    }

    // Encodable protocol methods

    internal func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(rewardType, forKey: .rewardType)
        try container.encodeIfPresent(rewardOpenBalance, forKey: .rewardOpenBalance)
        try container.encodeIfPresent(rewardBalance, forKey: .rewardBalance)
        try container.encodeIfPresent(rewardEarned, forKey: .rewardEarned)
        try container.encodeIfPresent(rewardRedeemed, forKey: .rewardRedeemed)
        try container.encodeIfPresent(rewardAdjust, forKey: .rewardAdjust)
        try container.encodeIfPresent(rewardTotalEarned, forKey: .rewardTotalEarned)
    }
}

